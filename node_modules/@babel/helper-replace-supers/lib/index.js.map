{"version":3,"names":["_helperEnvironmentVisitor","require","_helperMemberExpressionToFunctions","_helperOptimiseCallExpression","_core","assignmentExpression","booleanLiteral","callExpression","cloneNode","identifier","memberExpression","sequenceExpression","stringLiteral","thisExpression","t","ns","exports","environmentVisitor","default","skipAllButComputedKey","getPrototypeOfExpression","objectRef","isStatic","file","isPrivateMethod","targetRef","addHelper","visitor","traverse","visitors","merge","Super","path","state","node","parentPath","isMemberExpression","object","handle","unshadowSuperBindingVisitor","Scopable","refName","binding","scope","getOwnBinding","name","rename","specHandlers","memoise","superMember","count","computed","property","memo","maybeGenerateMemoised","memoiser","set","prop","has","get","_get","_getThisRefs","thisRefs","proto","getObjectRef","needAccessFirst","this","isDerivedConstructor","value","isInStrictMode","destructureSet","buildCodeFrameError","call","args","optimiseCall","optionalCall","delete","template","expression","ast","looseHandlers","Object","assign","getSuperRef","_getSuperRef","_getSuperRef2","ReplaceSupers","constructor","opts","_opts$constantSuper","methodPath","isClassMethod","kind","superRef","isObjectMethod","static","isStaticBlock","isPrivate","isMethod","constantSuper","isLoose","replace","refToPreserve","handler","shouldSkip","parentKey","memberExpressionToFunctions","bind","boundGet"],"sources":["../src/index.ts"],"sourcesContent":["import type { File } from \"@babel/core\";\nimport environmentVisitor from \"@babel/helper-environment-visitor\";\nimport memberExpressionToFunctions from \"@babel/helper-member-expression-to-functions\";\nimport type { HandlerState } from \"@babel/helper-member-expression-to-functions\";\nimport optimiseCall from \"@babel/helper-optimise-call-expression\";\nimport { traverse, template, types as t } from \"@babel/core\";\nimport type { NodePath, Scope } from \"@babel/traverse\";\nconst {\n  assignmentExpression,\n  booleanLiteral,\n  callExpression,\n  cloneNode,\n  identifier,\n  memberExpression,\n  sequenceExpression,\n  stringLiteral,\n  thisExpression,\n} = t;\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM && !IS_STANDALONE) {\n  // eslint-disable-next-line no-restricted-globals\n  const ns = require(\"@babel/helper-environment-visitor\");\n  // eslint-disable-next-line no-restricted-globals\n  exports.environmentVisitor = ns.default;\n  // eslint-disable-next-line no-restricted-globals\n  exports.skipAllButComputedKey = ns.skipAllButComputedKey;\n}\n\ntype ThisRef = {\n  needAccessFirst?: boolean;\n  this: t.ThisExpression;\n};\n\n/**\n * Creates an expression which result is the proto of objectRef.\n *\n * @example <caption>isStatic === true</caption>\n *\n *   helpers.getPrototypeOf(CLASS)\n *\n * @example <caption>isStatic === false</caption>\n *\n *   helpers.getPrototypeOf(CLASS.prototype)\n */\nfunction getPrototypeOfExpression(\n  objectRef: t.Identifier,\n  isStatic: boolean,\n  file: File,\n  isPrivateMethod: boolean,\n) {\n  objectRef = cloneNode(objectRef);\n  const targetRef =\n    isStatic || isPrivateMethod\n      ? objectRef\n      : memberExpression(objectRef, identifier(\"prototype\"));\n\n  return callExpression(file.addHelper(\"getPrototypeOf\"), [targetRef]);\n}\n\nconst visitor = traverse.visitors.merge<\n  HandlerState<ReplaceState> & ReplaceState\n>([\n  environmentVisitor,\n  {\n    Super(path, state) {\n      const { node, parentPath } = path;\n      if (!parentPath.isMemberExpression({ object: node })) return;\n      state.handle(parentPath);\n    },\n  },\n]);\n\nconst unshadowSuperBindingVisitor = traverse.visitors.merge<{\n  refName: string;\n}>([\n  environmentVisitor,\n  {\n    Scopable(path, { refName }) {\n      // https://github.com/Zzzen/babel/pull/1#pullrequestreview-564833183\n      const binding = path.scope.getOwnBinding(refName);\n      if (binding && binding.identifier.name === refName) {\n        path.scope.rename(refName);\n      }\n    },\n  },\n]);\n\ntype SharedState = {\n  file: File;\n  scope: Scope;\n  isDerivedConstructor: boolean;\n  isStatic: boolean;\n  isPrivateMethod: boolean;\n  getObjectRef: () => t.Identifier;\n  getSuperRef: () => t.Identifier;\n  // we dont need boundGet here, but memberExpressionToFunctions handler needs it.\n  boundGet: HandlerState[\"get\"];\n};\n\ntype Handler = HandlerState<SharedState> & SharedState;\ntype SuperMember = NodePath<\n  t.MemberExpression & {\n    object: t.Super;\n    property: Exclude<t.MemberExpression[\"property\"], t.PrivateName>;\n  }\n>;\n\ninterface SpecHandler\n  extends Pick<\n    Handler,\n    | \"memoise\"\n    | \"get\"\n    | \"set\"\n    | \"destructureSet\"\n    | \"call\"\n    | \"optionalCall\"\n    | \"delete\"\n  > {\n  _get(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    thisRefs: ThisRef,\n  ): t.CallExpression;\n  _getThisRefs(): ThisRef;\n  prop(this: Handler & SpecHandler, superMember: SuperMember): t.Expression;\n}\n\nconst specHandlers: SpecHandler = {\n  memoise(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    count: number,\n  ) {\n    const { scope, node } = superMember;\n    const { computed, property } = node;\n    if (!computed) {\n      return;\n    }\n\n    const memo = scope.maybeGenerateMemoised(property);\n    if (!memo) {\n      return;\n    }\n\n    this.memoiser.set(property, memo, count);\n  },\n\n  prop(this: Handler & SpecHandler, superMember: SuperMember) {\n    const { computed, property } = superMember.node;\n    if (this.memoiser.has(property)) {\n      return cloneNode(this.memoiser.get(property));\n    }\n\n    if (computed) {\n      return cloneNode(property);\n    }\n\n    return stringLiteral((property as t.Identifier).name);\n  },\n\n  get(this: Handler & SpecHandler, superMember: SuperMember) {\n    return this._get(superMember, this._getThisRefs());\n  },\n\n  _get(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    thisRefs: ThisRef,\n  ) {\n    const proto = getPrototypeOfExpression(\n      this.getObjectRef(),\n      this.isStatic,\n      this.file,\n      this.isPrivateMethod,\n    );\n    return callExpression(this.file.addHelper(\"get\"), [\n      thisRefs.needAccessFirst\n        ? sequenceExpression([thisRefs.this, proto])\n        : proto,\n      this.prop(superMember),\n      thisRefs.this,\n    ]);\n  },\n\n  _getThisRefs(this: Handler & SpecHandler): ThisRef {\n    return {\n      needAccessFirst: this.isDerivedConstructor,\n      this: thisExpression(),\n    };\n  },\n\n  set(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    value: t.Expression,\n  ) {\n    const thisRefs = this._getThisRefs();\n    const proto = getPrototypeOfExpression(\n      this.getObjectRef(),\n      this.isStatic,\n      this.file,\n      this.isPrivateMethod,\n    );\n    return callExpression(this.file.addHelper(\"set\"), [\n      thisRefs.needAccessFirst\n        ? sequenceExpression([thisRefs.this, proto])\n        : proto,\n      this.prop(superMember),\n      value,\n      thisRefs.this,\n      booleanLiteral(superMember.isInStrictMode()),\n    ]);\n  },\n\n  destructureSet(this: Handler & SpecHandler, superMember: SuperMember) {\n    throw superMember.buildCodeFrameError(\n      `Destructuring to a super field is not supported yet.`,\n    );\n  },\n\n  call(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    args: t.CallExpression[\"arguments\"],\n  ) {\n    const thisRefs = this._getThisRefs();\n    return optimiseCall(\n      this._get(superMember, thisRefs),\n      cloneNode(thisRefs.this),\n      args,\n      false,\n    );\n  },\n\n  optionalCall(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    args: t.CallExpression[\"arguments\"],\n  ) {\n    const thisRefs = this._getThisRefs();\n    return optimiseCall(\n      this._get(superMember, thisRefs),\n      cloneNode(thisRefs.this),\n      args,\n      true,\n    );\n  },\n\n  delete(this: Handler & SpecHandler, superMember: SuperMember) {\n    if (superMember.node.computed) {\n      return sequenceExpression([\n        callExpression(this.file.addHelper(\"toPropertyKey\"), [\n          cloneNode(superMember.node.property),\n        ]),\n        template.expression.ast`\n          function () { throw new ReferenceError(\"'delete super[expr]' is invalid\"); }()\n        `,\n      ]);\n    } else {\n      return template.expression.ast`\n        function () { throw new ReferenceError(\"'delete super.prop' is invalid\"); }()\n      `;\n    }\n  },\n};\n\nconst looseHandlers = {\n  ...specHandlers,\n\n  prop(this: Handler & typeof specHandlers, superMember: SuperMember) {\n    const { property } = superMember.node;\n    if (this.memoiser.has(property)) {\n      return cloneNode(this.memoiser.get(property));\n    }\n\n    return cloneNode(property);\n  },\n\n  get(this: Handler & typeof specHandlers, superMember: SuperMember) {\n    const { isStatic, getSuperRef } = this;\n    const { computed } = superMember.node;\n    const prop = this.prop(superMember);\n\n    let object;\n    if (isStatic) {\n      object =\n        getSuperRef() ??\n        memberExpression(identifier(\"Function\"), identifier(\"prototype\"));\n    } else {\n      object = memberExpression(\n        getSuperRef() ?? identifier(\"Object\"),\n        identifier(\"prototype\"),\n      );\n    }\n\n    return memberExpression(object, prop, computed);\n  },\n\n  set(\n    this: Handler & typeof specHandlers,\n    superMember: SuperMember,\n    value: t.Expression,\n  ) {\n    const { computed } = superMember.node;\n    const prop = this.prop(superMember);\n\n    return assignmentExpression(\n      \"=\",\n      memberExpression(thisExpression(), prop, computed),\n      value,\n    );\n  },\n\n  destructureSet(\n    this: Handler & typeof specHandlers,\n    superMember: SuperMember,\n  ) {\n    const { computed } = superMember.node;\n    const prop = this.prop(superMember);\n\n    return memberExpression(thisExpression(), prop, computed);