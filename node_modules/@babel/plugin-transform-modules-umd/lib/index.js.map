{"version":3,"names":["_helperPluginUtils","require","_path","_helperModuleTransforms","_core","buildPrerequisiteAssignment","template","buildWrapper","_default","exports","default","declare","api","options","_api$assumption","_api$assumption2","assertVersion","globals","exactGlobals","allowTopLevelThis","strict","strictMode","noInterop","importInterop","constantReexports","assumption","loose","enumerableModuleMeta","buildBrowserInit","browserGlobals","filename","moduleName","moduleNameOrBasename","value","basename","extname","globalToAssign","t","memberExpression","identifier","toIdentifier","initAssignments","globalName","members","split","slice","reduce","accum","curr","push","GLOBAL_REFERENCE","cloneNode","expressionStatement","assignmentExpression","buildBrowserArg","source","globalRef","requireName","name","visitor","Program","exit","path","isModule","getModuleName","file","opts","moduleNameLiteral","stringLiteral","meta","headers","rewriteModuleStatementsAndPrepareHeader","amdArgs","commonjsArgs","browserArgs","importNames","hasExports","exportName","metadata","callExpression","isSideEffectImport","interop","wrapInterop","header","loc","buildNamespaceInitStatements","ensureStatementsHoisted","unshiftContainer","body","directives","node","umdWrapper","pushContainer","MODULE_NAME","AMD_ARGUMENTS","arrayExpression","COMMONJS_ARGUMENTS","BROWSER_ARGUMENTS","IMPORT_NAMES","GLOBAL_TO_ASSIGN","umdFactory","get"],"sources":["../src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { basename, extname } from \"path\";\nimport {\n  isModule,\n  rewriteModuleStatementsAndPrepareHeader,\n  type RewriteModuleStatementsAndPrepareHeaderOptions,\n  hasExports,\n  isSideEffectImport,\n  buildNamespaceInitStatements,\n  ensureStatementsHoisted,\n  wrapInterop,\n  getModuleName,\n} from \"@babel/helper-module-transforms\";\nimport type { PluginOptions } from \"@babel/helper-module-transforms\";\nimport { types as t, template } from \"@babel/core\";\nimport type { NodePath } from \"@babel/traverse\";\n\nconst buildPrerequisiteAssignment = template(`\n  GLOBAL_REFERENCE = GLOBAL_REFERENCE || {}\n`);\n// Note: we avoid comparing typeof results with \"object\" or \"symbol\" otherwise\n// they will be processed by `transform-typeof-symbol`, which in return could\n// cause typeof helper used before declaration\nconst buildWrapper = template(`\n  (function (global, factory) {\n    if (typeof define === \"function\" && define.amd) {\n      define(MODULE_NAME, AMD_ARGUMENTS, factory);\n    } else if (typeof exports !== \"undefined\") {\n      factory(COMMONJS_ARGUMENTS);\n    } else {\n      var mod = { exports: {} };\n      factory(BROWSER_ARGUMENTS);\n\n      GLOBAL_TO_ASSIGN;\n    }\n  })(\n    typeof globalThis !== \"undefined\" ? globalThis\n      : typeof self !== \"undefined\" ? self\n      : this,\n    function(IMPORT_NAMES) {\n  })\n`);\n\nexport interface Options extends PluginOptions {\n  allowTopLevelThis?: boolean;\n  exactGlobals?: boolean;\n  globals?: Record<string, string>;\n  importInterop?: RewriteModuleStatementsAndPrepareHeaderOptions[\"importInterop\"];\n  loose?: boolean;\n  noInterop?: boolean;\n  strict?: boolean;\n  strictMode?: boolean;\n}\n\nexport default declare((api, options: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const {\n    globals,\n    exactGlobals,\n    allowTopLevelThis,\n    strict,\n    strictMode,\n    noInterop,\n    importInterop,\n  } = options;\n\n  const constantReexports =\n    api.assumption(\"constantReexports\") ?? options.loose;\n  const enumerableModuleMeta =\n    api.assumption(\"enumerableModuleMeta\") ?? options.loose;\n\n  /**\n   * Build the assignment statements that initialize the UMD global.\n   */\n  function buildBrowserInit(\n    browserGlobals: Record<string, string>,\n    exactGlobals: boolean,\n    filename: string,\n    moduleName: t.StringLiteral | void,\n  ) {\n    const moduleNameOrBasename = moduleName\n      ? moduleName.value\n      : basename(filename, extname(filename));\n    let globalToAssign = t.memberExpression(\n      t.identifier(\"global\"),\n      t.identifier(t.toIdentifier(moduleNameOrBasename)),\n    );\n    let initAssignments = [];\n\n    if (exactGlobals) {\n      const globalName = browserGlobals[moduleNameOrBasename];\n\n      if (globalName) {\n        initAssignments = [];\n\n        const members = globalName.split(\".\");\n        globalToAssign = members.slice(1).reduce(\n          (accum, curr) => {\n            initAssignments.push(\n              buildPrerequisiteAssignment({\n                GLOBAL_REFERENCE: t.cloneNode(accum),\n              }),\n            );\n            return t.memberExpression(accum, t.identifier(curr));\n          },\n          t.memberExpression(t.identifier(\"global\"), t.identifier(members[0])),\n        );\n      }\n    }\n\n    initAssignments.push(\n      t.expressionStatement(\n        t.assignmentExpression(\n          \"=\",\n          globalToAssign,\n          t.memberExpression(t.identifier(\"mod\"), t.identifier(\"exports\")),\n        ),\n      ),\n    );\n\n    return initAssignments;\n  }\n\n  /**\n   * Build the member expression that reads from a global for a given source.\n   */\n  function buildBrowserArg(\n    browserGlobals: Record<string, string>,\n    exactGlobals: boolean,\n    source: string,\n  ) {\n    let memberExpression: t.MemberExpression;\n    if (exactGlobals) {\n      const globalRef = browserGlobals[source];\n      if (globalRef) {\n        memberExpression = globalRef\n          .split(\".\")\n          .reduce(\n            (accum: t.Identifier | t.MemberExpression, curr) =>\n              t.memberExpression(accum, t.identifier(curr)),\n            t.identifier(\"global\"),\n          ) as t.MemberExpression;\n      } else {\n        memberExpression = t.memberExpression(\n          t.identifier(\"global\"),\n          t.identifier(t.toIdentifier(source)),\n        );\n      }\n    } else {\n      const requireName = basename(source, extname(source));\n      const globalName = browserGlobals[requireName] || requireName;\n      memberExpression = t.memberExpression(\n        t.identifier(\"global\"),\n        t.identifier(t.toIdentifier(globalName)),\n      );\n    }\n    return memberExpression;\n  }\n\n  return {\n    name: \"transform-modules-umd\",\n\n    visitor: {\n      Program: {\n        exit(path) {\n          if (!isModule(path)) return;\n\n          const browserGlobals = globals || {};\n\n          const moduleName = getModuleName(this.file.opts, options);\n          let moduleNameLiteral: void | t.StringLiteral;\n          if (moduleName) moduleNameLiteral = t.stringLiteral(moduleName);\n\n          const { meta, headers } = rewriteModuleStatementsAndPrepareHeader(\n            path,\n            {\n              constantReexports,\n              enumerableModuleMeta,\n              strict,\n              strictMode,\n              allowTopLevelThis,\n              noInterop,\n              importInterop,\n              filename: this.file.opts.filename,\n            },\n          );\n\n          const amdArgs = [];\n          const commonjsArgs = [];\n          const browserArgs = [];\n          const importNames = [];\n\n          if (hasExports(meta)) {\n            amdArgs.push(t.stringLiteral(\"exports\"));\n            commonjsArgs.push(t.identifier(\"exports\"));\n            browserArgs.push(\n              t.memberExpression(t.identifier(\"mod\"), t.identifier(\"exports\")),\n            );\n            importNames.push(t.identifier(meta.exportName));\n          }\n\n          for (const [source, metadata] of meta.source) {\n            amdArgs.push(t.stringLiteral(source));\n            commonjsArgs.push(\n              t.callExpression(t.identifier(\"require\"), [\n                t.stringLiteral(source),\n              ]),\n            );\n            browserArgs.push(\n              buildBrowserArg(browserGlobals, exactGlobals, source),\n            );\n            importNames.push(t.identifier(metadata.name));\n\n            if (!isSideEffectImport(metadata)) {\n              const interop = wrapInterop(\n                path,\n                t.identifier(metadata.name),\n                metadata.interop,\n              );\n              if (interop) {\n                const header = t.expressionStatement(\n                  t.assignmentExpression(\n                    \"=\",\n                    t.identifier(metadata.name),\n                    interop,\n                  ),\n                );\n                // @ts-expect-error todo(flow->ts)\n                header.loc = meta.loc;\n                headers.push(header);\n              }\n            }\n\n            headers.push(\n              ...buildNamespaceInitStatements(\n                meta,\n                metadata,\n                constantReexports,\n              ),\n            );\n          }\n\n          ensureStatementsHoisted(headers);\n          path.unshiftContainer(\"body\", headers);\n\n          const { body, directives } = path.node;\n          path.node.directives = [];\n          path.node.body = [];\n          const umdWrapper = path.pushContainer(\"body\", [\n            buildWrapper({\n              //todo: buildWrapper does not handle void moduleNameLiteral\n              MODULE_NAME: moduleNameLiteral,\n\n              AMD_ARGUMENTS: t.arrayExpression(amdArgs),\n              COMMONJS_ARGUMENTS: commonjsArgs,\n              BROWSER_ARGUMENTS: browserArgs,\n              IMPORT_NAMES: importNames,\n\n              GLOBAL_TO_ASSIGN: buildBrowserInit(\n                browserGlobals,\n                exactGlobals,\n                this.filename || \"unknown\",\n                moduleNameLiteral,\n              ),\n            }) as t.Statement,\n          ])[0] as NodePath<t.ExpressionStatement>;\n          const umdFactory = (\n            umdWrapper.get(\"expression.arguments\")[1] as NodePath<t.Function>\n          ).get(\"body\") as NodePath<t.BlockStatement>;\n          