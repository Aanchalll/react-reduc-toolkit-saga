{"version":3,"names":["_helperPluginUtils","require","_core","_noHelperImplementation","_helperSkipTransparentExpressionWrappers","buildLoopBody","path","declar","newBody","block","bodyPath","get","body","node","t","isBlockStatement","Object","keys","getBindingIdentifiers","some","id","scope","hasOwnBinding","blockStatement","toBlock","unshift","_default","exports","default","declare","api","options","_options$assumeArray","_options$allowArrayLi","_api$assumption","assertVersion","assumeArray","allowArrayLike","loose","Error","test","version","iterableIsArray","assumption","arrayLikeIsIterable","skipIteratorClosing","name","visitor","ForOfStatement","left","await","isAwait","right","skipTransparentExprWrapperNodes","i","generateUidIdentifier","array","maybeGenerateMemoised","isIdentifier","inits","variableDeclarator","numericLiteral","push","item","memberExpression","cloneNode","assignment","isVariableDeclaration","declarations","init","expressionStatement","assignmentExpression","replaceWith","forStatement","variableDeclaration","binaryExpression","identifier","updateExpression","buildForOfArray","template","buildForOfNoIteratorClosing","statements","buildForOf","builder","build","helper","getContainer","nodes","_ForOfStatementArray","generateUidIdentifierBasedOnNode","iterationKey","loop","BODY","KEY","NAME","ARR","inherits","iterationValue","state","isArrayExpression","isGenericType","isArrayTypeAnnotation","getTypeAnnotation","availableHelper","transformWithoutHelper","parent","stepKey","generateUid","stepValue","kind","CREATE_ITERATOR_HELPER","addHelper","ITERATOR_HELPER","ARRAY_LIKE_IS_ITERABLE","booleanLiteral","STEP_KEY","OBJECT","container","isLabeledStatement","labeledStatement","label","parentPath","replaceWithMultiple","skip"],"sources":["../src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { template, types as t } from \"@babel/core\";\nimport type { NodePath } from \"@babel/traverse\";\n\nimport transformWithoutHelper from \"./no-helper-implementation.ts\";\nimport { skipTransparentExprWrapperNodes } from \"@babel/helper-skip-transparent-expression-wrappers\";\n\nexport interface Options {\n  allowArrayLike?: boolean;\n  assumeArray?: boolean;\n  loose?: boolean;\n}\n\nfunction buildLoopBody(\n  path: NodePath<t.ForXStatement>,\n  declar: t.Statement,\n  newBody?: t.Statement | t.Expression,\n) {\n  let block;\n  const bodyPath = path.get(\"body\");\n  const body = newBody ?? bodyPath.node;\n  if (\n    t.isBlockStatement(body) &&\n    Object.keys(path.getBindingIdentifiers()).some(id =>\n      bodyPath.scope.hasOwnBinding(id),\n    )\n  ) {\n    block = t.blockStatement([declar, body]);\n  } else {\n    block = t.toBlock(body);\n    block.body.unshift(declar);\n  }\n  return block;\n}\n\nexport default declare((api, options: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  {\n    const { assumeArray, allowArrayLike, loose } = options;\n\n    if (loose === true && assumeArray === true) {\n      throw new Error(\n        `The loose and assumeArray options cannot be used together in @babel/plugin-transform-for-of`,\n      );\n    }\n\n    if (assumeArray === true && allowArrayLike === true) {\n      throw new Error(\n        `The assumeArray and allowArrayLike options cannot be used together in @babel/plugin-transform-for-of`,\n      );\n    }\n\n    if (!process.env.BABEL_8_BREAKING) {\n      // TODO: Remove in Babel 8\n      if (allowArrayLike && /^7\\.\\d\\./.test(api.version)) {\n        throw new Error(\n          `The allowArrayLike is only supported when using @babel/core@^7.10.0`,\n        );\n      }\n    }\n  }\n\n  const iterableIsArray =\n    options.assumeArray ??\n    // Loose mode is not compatible with 'assumeArray', so we shouldn't read\n    // 'iterableIsArray' if 'loose' is true.\n    (!options.loose && api.assumption(\"iterableIsArray\"));\n\n  const arrayLikeIsIterable =\n    options.allowArrayLike ?? api.assumption(\"arrayLikeIsIterable\");\n\n  const skipIteratorClosing =\n    api.assumption(\"skipForOfIteratorClosing\") ?? options.loose;\n\n  if (iterableIsArray && arrayLikeIsIterable) {\n    throw new Error(\n      `The \"iterableIsArray\" and \"arrayLikeIsIterable\" assumptions are not compatible.`,\n    );\n  }\n\n  if (iterableIsArray) {\n    return {\n      name: \"transform-for-of\",\n\n      visitor: {\n        ForOfStatement(path) {\n          const { scope } = path;\n          const { left, await: isAwait } = path.node;\n          if (isAwait) {\n            return;\n          }\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n          const right = skipTransparentExprWrapperNodes(\n            path.node.right,\n          ) as t.Expression;\n          const i = scope.generateUidIdentifier(\"i\");\n          let array: t.Identifier | t.ThisExpression =\n            scope.maybeGenerateMemoised(right, true);\n          if (\n            !array &&\n            t.isIdentifier(right) &&\n            path.get(\"body\").scope.hasOwnBinding(right.name)\n          ) {\n            array = scope.generateUidIdentifier(\"arr\");\n          }\n\n          const inits = [t.variableDeclarator(i, t.numericLiteral(0))];\n          if (array) {\n            inits.push(t.variableDeclarator(array, right));\n          } else {\n            array = right as t.Identifier | t.ThisExpression;\n          }\n\n          const item = t.memberExpression(\n            t.cloneNode(array),\n            t.cloneNode(i),\n            true,\n          );\n          let assignment;\n          if (t.isVariableDeclaration(left)) {\n            assignment = left;\n            assignment.declarations[0].init = item;\n          } else {\n            assignment = t.expressionStatement(\n              t.assignmentExpression(\"=\", left, item),\n            );\n          }\n\n          path.replaceWith(\n            t.forStatement(\n              t.variableDeclaration(\"let\", inits),\n              t.binaryExpression(\n                \"<\",\n                t.cloneNode(i),\n                t.memberExpression(t.cloneNode(array), t.identifier(\"length\")),\n              ),\n              t.updateExpression(\"++\", t.cloneNode(i)),\n              buildLoopBody(path, assignment),\n            ),\n          );\n        },\n      },\n    };\n  }\n\n  const buildForOfArray = template`\n    for (var KEY = 0, NAME = ARR; KEY < NAME.length; KEY++) BODY;\n  `;\n\n  const buildForOfNoIteratorClosing = template.statements`\n    for (var ITERATOR_HELPER = CREATE_ITERATOR_HELPER(OBJECT, ARRAY_LIKE_IS_ITERABLE), STEP_KEY;\n        !(STEP_KEY = ITERATOR_HELPER()).done;) BODY;\n  `;\n\n  const buildForOf = template.statements`\n    var ITERATOR_HELPER = CREATE_ITERATOR_HELPER(OBJECT, ARRAY_LIKE_IS_ITERABLE), STEP_KEY;\n    try {\n      for (ITERATOR_HELPER.s(); !(STEP_KEY = ITERATOR_HELPER.n()).done;) BODY;\n    } catch (err) {\n      ITERATOR_HELPER.e(err);\n    } finally {\n      ITERATOR_HELPER.f();\n    }\n  `;\n\n  const builder = skipIteratorClosing\n    ? {\n        build: buildForOfNoIteratorClosing,\n        helper: \"createForOfIteratorHelperLoose\",\n        getContainer: (nodes: t.Statement[]): [t.ForStatement] =>\n          nodes as [t.ForStatement],\n      }\n    : {\n        build: buildForOf,\n        helper: \"createForOfIteratorHelper\",\n        getContainer: (nodes: t.Statement[]): [t.ForStatement] =>\n          (nodes[1] as t.TryStatement).block.body as [t.ForStatement],\n      };\n\n  function _ForOfStatementArray(path: NodePath<t.ForOfStatement>) {\n    const { node, scope } = path;\n\n    const right = scope.generateUidIdentifierBasedOnNode(node.right, \"arr\");\n    const iterationKey = scope.generateUidIdentifier(\"i\");\n